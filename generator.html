<html>

<head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <title>generator</title>
    <!-- 告诉浏览器该页面是自适应布局 -->
    <meta content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no" name="viewport">

</head>

<body>
    <script>
        // Gernerator函数返回的遍历器对象，只有调用next方法才会遍历下一个内部状态，所以其实提供了一种可以暂停执行的函数。
        // yield 表达式是暂停标志

        function* foo(x) {
            var y = 2 * (yield(x + 1));
            var z = yield(y / 3);
            return (x + y + z);
        }

        var a = foo(5);
        // next方法的参数表示上一个yield表达式的返回值，
        console.log(a.next()) // Object{value:6, done:false}
        console.log(a.next(3)) // Object{value:NaN, done:false}
        console.log(a.next()) // Object{value:NaN, done:true}


        // for...of 循环可以自动遍历Generator函数时生成Iterator对象，此时不再需要调用next方法

        // next方法的参数表示上一个yield表达式的返回值，所以在第一次使用next方法时，传递参数是无效的
        


    </script>

</body>

</html>